#include "Translator.h"

pair<bool, string> LL::E(const string& scope) {
    nextState(0); //Переключение в новое состояние, фиксирует состояние узла как начальное
    addString("E7"); //Добавляет узел "E7" в дерево разбора
    auto result = E7(scope); //Вызывает функцию E7, которая разбирает выражение на уровне E7
    if (!result.first) { return { false, "" }; } //Если разбор не удался, возвращает ошибку
    backStateIt(); //Удаляет текущий узел из дерева, так как обработка завершена
    return { true, result.second }; //возвращает успешный результат разбора
}

pair<bool, string> LL::E7(const string& scope) {

    nextState(1); //Добавляет текущий узел в дерево как левый
    addString("E6"); //Добавляет узел "E6" в дерево
    auto result = E6(scope); //вызывает функцию E6 для разбора части выражения
    if (!result.first) { return { false, "" }; } //Если разбор не удался, возвращает ошибку

    nextState(0); //Переключает узел в правый
    addString("E7\'"); //добавляет узел "E7'" в дерево
    result = E7list(scope, result.second); //Вызывает функцию E7list, которая разбирает операторы "ИЛИ" и их выражения
    if (!result.first) { return { false, "" }; } //Если разбор не удался, возвращает ошибку
    backStateIt(); //Удаляет текущий узел из дерева
    return { true, result.second }; //Возвращает успешный результат разбора
}

pair<bool, string> LL::E7list(const string& scope, const string& p) {
    if (iter->first == "opor") { //Проверяет, является ли текущая лексема оператором "ИЛИ" (OR)
        setLexem(); // берем следующую лексему

        //Добавляет узел "opor E6" в дерево, фиксируя текущий оператор
        nextState(1); // добавляет текущий узел для дерева в вектор и говорит, что он не является правым
        addString("opor E6"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов   

        auto result = E6(scope); //Вызывает функцию E6 для разбора выражения на уровне логических операций
        if (!result.first) return { false, "" }; //Если разбор не удался, возвращает ошибку

        
        nextState(0); //Переключает узел в правый
        addString("E7\'"); //добавляет узел "E7'" в дерево

        auto s = alloc(scope); // создаем новую временную переменную
        addAtom({ scope, "OR", p, result.second, s }); //Добавляет атомарную операцию "OR", которая выполняет логическое "ИЛИ" между левым выражением p и правым результатом result.second. Результат сохраняется в переменной s

        result = E7list(scope, s); //Рекурсивно вызывает E7list, чтобы обработать следующее выражение с оператором "ИЛИ", если оно есть
        if (!result.first) { return { false, "" }; } //Если разбор не удался, возвращает ошибку
        backStateIt(); //Удаляет текущий узел из дерева
        return { true, result.second }; //возвращает успешный результат разбора
    }
    //Если оператор "ИЛИ" отсутствует. Удаляет текущий узел и возвращает текущее выражение без изменений
    backStateIt();
    return { true, p };
}

pair<bool, string> LL::E6(const string& scope) {

    //Добавляет узел "E5" в дерево, фиксируя текущее состояние
    nextState(1); // добавляет текущий узел для дерева в вектор и говорит, что он не является правым
    addString("E5"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов

    auto result = E5(scope); //Вызывает функцию E5 для разбора выражения на уровне операторов сравнения
    if (!result.first) { return { false, "" }; } //Если разбор не удался, возвращает ошибку

    //Переключает узел в правое состояние и добавляет узел "E6'" в дерево
    nextState(0); 
    addString("E6\'");

    result = E6list(scope, result.second); //Вызывает функцию E6list, которая проверяет и обрабатывает операторы логического "И" (AND)
    if (!result.first) { return { false, "" }; } //Если разбор не удался, возвращает ошибку

    //Удаляет текущий узел и возвращает успешный результат с выражением
    backStateIt(); 
    return { true, result.second };
}

pair<bool, string> LL::E6list(const string& scope, const string& p) {
    if (iter->first == "opand") { //Проверяется, является ли текущий токен оператором логического "И" (AND)
        setLexem(); // берем следующую лексему

        //Фиксируется текущий узел в векторе узлов и добавляется узел с названием "opand E5" в дерево выражений
        nextState(1); 
        addString("opand E5"); 

        auto result = E5(scope); //Вызов функции E5 для обработки подвыражения уровня E5 (то есть выражений ниже уровня логического "И")
        if (!result.first) { return { false, "" }; } //Если разбор неуспешен, возвращается ошибка

        //Фиксируется узел как правый, добавляется узел с названием "E6'" в дерево выражений
        nextState(0); 
        addString("E6\'");

        auto s = alloc(scope); // создаем новую временную переменную
        addAtom({ scope, "AND", p, result.second, s }); //добавляется атомарная операция "AND", где p — левая часть выражения, result.second — правая часть, результат записывается в переменную s

        result = E6list(scope, s); //Рекурсивный вызов функции для обработки следующего оператора AND, если он присутствует
        if (!result.first) { return { false, "" }; } // Если разбор неуспешен, возвращается ошибка

        //Удаляет текущий узел из дерева и возвращает успешный результат с конечным выражением
        backStateIt(); 
        return { true, result.second };
    }
    //Если оператор "И" отсутствует, функция просто возвращает текущий результат
    backStateIt(); 
    return { true, p };
}
pair<bool, string> LL::E5(const string& scope) { // scope - контекст

    //Фиксируется текущий узел в векторе и добавляется узел с названием "E4" в дерево
    nextState(1); 
    addString("E4");

    auto result = E4(scope); //Вызов функции E4 для разбора выражения на уровне арифметических операций сложения/вычитания
    if (!result.first) { return { false, "" }; } //Если разбор E4 завершился неуспешно, возвращается ошибка

    //Фиксируется узел как правый, добавляется узел с названием "E5'" в дерево выражений
    nextState(0); 
    addString("E5\'");

    result = E5list(scope, result.second); //Вызов функции E5list, которая будет проверять наличие дополнительных операций на уровне E5
    if (!result.first) { return { false, "" }; } //Если разбор неуспешен, возвращается ошибка
    backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
    return { true, result.second }; //Возвращается успешный результат анализа выражения
}

pair<bool, string> LL::E5list(const string& scope, const string& p) {
    if (iter->first == "opeq" or iter->first == "opne" or iter->first == "oplt" or iter->first == "opgt" or 
        iter->first == "ople") { //// проверка, что сейчас лексему сравнения
        //Извлекается часть строки с оператором и переводится в верхний регистр для использования в атомарных операциях
        auto item = iter->first.substr(2, iter->first.size()); // запоминаем лексему сранения
        transform(item.begin(), item.end(), item.begin(), ::toupper); // переводим все буквы в верхний регистр, чтобы использовать в атомах

        nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
        addString(iter->first + " E4"); //добавляется узел с названием оператора сравнения и выражения E4
        setLexem(); // берем следующую лексему

        auto result = E4(scope); //помещаем результат обхода дальше во временную переменную
        if (!result.first) { return { false, "" }; } // проверка, что верны данные дальше

        auto l = newLabel(); // генерируем номер новой метки
        auto s = alloc(scope); // создаем новую временную переменную
        addAtom({ scope, "MOV", "1", "", s }); //Добавляется атом "MOV", который присваивает 1 в переменную s, если условие сравнения выполнено

        //Добавляется атом сравнения item, который сравнивает левую часть выражения p с правой частью result.second.
        //Если условие истинно, прыгает к метке. После метки результат 1 или 0 записывается в переменную s
        addAtom({ scope, item, p, result.second, "$L" + l });
        addAtom({ scope, "MOV", "0", "", s }); 
        addAtom({ scope, "LBL", "", "", "$L" + l }); 

        backStateIt(); // удаляем уже обработанный узел из ветора текущих узлов
        return { true, s }; // говорит, что обработка выражения прошла успешно и возвращает результат этой обработки
    }
    backStateIt(); // удаляем уже обработанный узел из ветора текущих узлов
    return { true, p }; // говорит, что обработка выражения прошла успешно и возвращает результат этой обработки
}
pair<bool, string> LL::E4(const string& scope) {

    nextState(1); //Фиксирует текущий узел дерева в векторе узлов и указывает, что он не является правым узлом
    addString("E3"); //Рисует узел дерева с названием "E3"

    auto result = E3(scope); //Рекурсивно вызывает функцию E3 и получает её результат
    if (!result.first) { return { false, "" }; } //Проверяет, успешен ли разбор(если нет — выход)

    nextState(0); //Добавляет текущий узел дерева как правый
    addString("E4\'"); //Рисует узел дерева с названием "E4'"

    result = E4list(scope, result.second); //Вызывает E4list для обработки операторов сложения/вычитания
    if (!result.first) { return { false, "" }; } //Проверяет, успешен ли разбор. Если ошибка — возвращает неудачу
    backStateIt(); //Если разбор успешен, удаляет текущий узел из вектора и возвращает результат
    return { true, result.second }; 
}

pair<bool, string> LL::E4list(const string& scope, const string& p) {
    if (iter->first == "opplus") { //Проверяет, является ли текущая лексема оператором сложения
        setLexem(); //Считывает следующую лексему

        nextState(1); //Добавляет узел с названием "opplus E3" в дерево
        addString("opplus E3"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов

        auto result = E3(scope); //Разбирает следующее выражение (умножение/деление)
        if (!result.first) return { false, "" }; //Проверяет успешность разбора

        auto s = alloc(scope); //Создает временную переменную для результата
        addAtom({ scope, "ADD", p, result.second, s }); //Добавляет операцию сложения в список команд

        nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
        addString("E4\'"); //Добавляет узел с названием "E4'" в дерево

        result = E4list(scope, s); //Рекурсивно обрабатывает оставшуюся часть выражения
        if (!result.first) return { false, "" }; //Проверка успешности разбора

        backStateIt(); //Проверка успешности разбора
        return { true, result.second }; //Возвращает результат

    }
    else if (iter->first == "opminus") { //Обработка оператора вычитания
        setLexem(); // берем следующую лексему

        nextState(1); // добавляет текущий узел для дерева в вектор и говорит, что он не является правым
        addString("opminus E3"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов

        auto result = E3(scope); // помещаем результат обхода дальше во временную переменную
        if (!result.first) return { false, "" }; // проверка, что верны данные дальше. Если неудача — возвращает ошибку

        auto s = alloc(scope); // создаем новую временную переменную
        addAtom({ scope, "SUB",p, result.second, s }); //Добавляет операцию вычитания в список команд. Вычитает из результата первого выражения p результат второго выражения result.second, результат сохраняется в переменной s

        nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
        addString("E4\'"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов

        result = E4list(scope, s); //Рекурсивно обрабатывает оставшуюся часть выражения
        if (!result.first) return { false, "" }; // проверка, что верны данные дальше


        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
        return { true, result.second }; //Возвращает результат
    }

    //Если текущая лексема не является оператором сложения или вычитания, удаляет текущий узел из дерева и возвращает текущий результат
    backStateIt();
    return { true, p };
}

pair<bool, string> LL::E3(const string& scope) {

    //Фиксирует текущий узел дерева и добавляет узел с названием "E2", который будет визуализирован в дереве
    nextState(1); 
    addString("E2"); 

    auto result = E2(scope); // Вызывает функцию `E2` для разбора умножения/деления
    if (!result.first) { return { false, "" }; } //Проверка успешности разбора. Если неудача — возвращает ошибку

    nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
    addString("E3\'"); //Добавляет узел с названием "E3'" в дерево

    result = E3list(scope, result.second); //Рекурсивно вызывает E3list для обработки операторов умножения/деления
    if (!result.first) { return { false, "" }; } // проверка, что верны данные дальше
    backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
    return { true, result.second }; //Возвращает результат
}

pair<bool, string> LL::E3list(const string& scope, const string& p) {
    if (iter->first == "opmul") { //Проверяет, является ли текущая лексема оператором умножения
        setLexem(); //Считывает следующую лексему

        nextState(1); // добавляет текущий узел для дерева в вектор и говорит, что он не является правым
        addString("opmul E2"); //Рисует узел с названием "opmul E2" в дереве
         
        auto result = E2(scope); // помещаем результат обхода дальше во временную переменную
        if (!result.first) { return { false, "" }; } // проверка, что верны данные дальше

        nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
        addString("E3\'"); //Добавляет узел с названием "E3'" в дерево

        auto s = alloc(scope); // создаем новую временную переменную
        addAtom({ scope, "MUL", p, result.second, s }); //Добавляет операцию умножения в список команд

        result = E3list(scope, s); //Рекурсивно обрабатывает оставшиеся операторы
        if (!result.first) { return { false, "" }; } //Если результат функции E2 неудачен, возвращаем false

        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
        return { true, result.second }; //Удаляет текущий узел из дерева и возвращает успешный результат
    }
    backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
    return { true, p }; //Если оператор умножения не найден, возвращает успешный результат без изменений
}

pair<bool, string> LL::E2(const string& scope) {
    if (iter->first == "opnot") { //Проверка на оператор отрицания (opnot)
        setLexem(); // берем следующую лексему
        nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
        addString("opnot E1"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов

        auto result = E1(scope); // помещаем результат обхода дальше во временную переменную
        if (!result.first) { return { false, "" }; } // проверка, что верны данные дальше
        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов

        auto r = alloc(scope); // создаем новую временную переменную
        addAtom({ scope, "NOT", result.second, "", r }); //добавляем команду "NOT" (операция отрицания)
        return { true, r }; //Возвращает успешный результат
    }
    else { //Если оператор отрицания не найден, просто вызывает функцию E1, чтобы обработать выражение
        nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
        addString("E1"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов

        auto result = E1(scope); // помещаем результат обхода дальше во временную переменную
        if (!result.first) { return { false, "" }; } // проверка, что верны данные дальше

        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
        return { true, result.second };
    }
}

pair<bool, string> LL::E1(const string& scope) {
    if (iter->first == "opinc") { //Проверка на оператор инкремента (opinc)
        setLexem(); // берем следующую лексему

        if (iter->first != "id") { return { false, "" }; } //проверяет, является ли она идентификатором. Если нет, возвращает ошибку

        auto q = checkVar(scope, iter->second); //Проверяет переменную q и добавляет команду "ADD" для инкремента на 1
        addAtom({ scope, "ADD", q, "1", q });

        nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
        addString("opinc " + iter->second); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов
        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов

        setLexem(); // берем следующую лексему
        return { true, q }; //возвращает результат
    }
    else if (iter->first == "num" or iter->first == "char") { //Если текущая лексема — это число или символ, добавляет их в дерево и возвращает как результат
        auto item = iter->second;


        //Добавляет узел с именем инкремента в дерево, затем удаляет его
        nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
        addString(iter->second); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов
        setLexem(); // берем следующую лексему
        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
         

        return { true, item };
    }
    else if (iter->first == "lpar") {
        setLexem(); // берем следующую лексему
        nextState(1); // добавляет текущий узел для дерева в вектор и говорит, что он не является правым
        addString("lpar E"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов

        auto result = E(scope); // помещаем результат обхода дальше во временную переменную
        if (!result.first) { return { false, "" }; } // проверка, что верны данные дальше

        nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
        addString("rpar"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов
        if (iter->first != "rpar") { return { false, "" }; }
        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
        setLexem(); // берем следующую лексему
        return { true, result.second };
    }
    else if (iter->first == "id") { //Если текущая лексема — идентификатор, обрабатывает его
        auto name = iter->second; //Добавляет идентификатор в дерево, затем вызывает E1List для обработки операций с этим идентификатором

        nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
        addString(name + " E1\'"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов
        setLexem(); // берем следующую лексему

        auto result = E1List(scope, name); //Обрабатывает операции с идентификатором.Если успешно, возвращает результат
        if (!result.first) { return { false, "" }; } // проверка, что верны данные дальше
        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
        return { true, result.second };
    }

    return { false, "" }; //Возвращает неудачу, если ничего не подошло
}

pair<bool, string> LL::E1List(const string& scope, const string& p) {
    if (iter->first == "lpar") { //Проверяется, является ли текущая лексема открывающей скобкой lpar
        setLexem(); // берем следующую лексему

        nextState(1); //Добавляет текущий узел в дерево (в котором левый узел еще не закончен) и добавляет узел с названием "lpar Arglist"
        addString("lpar Arglist"); 

        auto result = Arglist(scope); //Вызывает функцию Arglist, которая обрабатывает список аргументов функции.
        if (!result.first) { return { false, "" }; } //Если обработка неудачна, возвращает ошибку


        //Добавляет узел "rpar" (закрывающая скобка).Проверяет, что следующая лексема — это закрывающая скобка rpar.Если да, удаляет обработанные узлы из дерева.
        nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
        addString("rpar"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов
        if (iter->first != "rpar") { return { false, "" }; } 
        setLexem(); // берем следующую лексему
        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов

        auto s = checkFunc(p, result.second); //Проверяет функцию checkFunc для вызова функции с именем p и аргументами result.second
        auto r = alloc(scope); // создаем новую временную переменную
        addAtom({ scope, "CALL", s, "", r }); //добавляет команду "CALL" для вызова функции в список команд

        return { true, r }; //Возвращает успешный результат и временную переменную
    }
    else if (iter->first == "opinc") { //Если текущая лексема — оператор инкремента opinc, читает следующую лексему, добавляет узел "opinc" в дерево, затем удаляет его
        setLexem(); // берем следующую лексему

        nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
        addString("opinc"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов
        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
        backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов

        auto s = checkVar(scope, p); //Проверяет переменную s в области видимости scope
        auto r = alloc(scope); // создаем новую временную переменную
        addAtom({ scope, "MOV", s, "", r }); //Добавляет команды "MOV" (копирование значения переменной s в r)
        addAtom({ scope, "ADD", s, "1", s }); //"ADD" (увеличение значения переменной s на 1)

        return { true, r }; //Возвращает успешный результат с временной переменной r
    }
    //Если не встретились вызов функции или инкремент, просто проверяет переменную q в области видимости scope и возвращает её
    backStateIt(); 
    auto q = checkVar(scope, p);
    return { true, q };
}
pair<bool, string> LL::Arglist(const string& scope) {
    if (iter->first != "num" and iter->first != "char" and iter->first != "id" and iter->first != "opinc" and iter->first != "lpar") {
        backStateIt(); //Если текущая лексема не является числом, символом, идентификатором, инкрементом или открывающей скобкой, то аргументов нет.
        return { true, "0" }; // Возвращает успех с результатом "0" (означает отсутствие аргументов)
    }
    //Добавляет текущий узел в дерево для аргумента, который обрабатывается как выражение E
    nextState(1); 
    addString(iter->second + " E"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов

    auto result1 = E(scope); //Вызывает функцию E, которая обрабатывает текущее выражение и возвращает результат
    if (!result1.first) return { false, "" }; //Если ошибка, возвращает неудачу
    nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
    addString("ArgList'"); //Добавляет узел "ArgList'" для оставшейся части списка аргументов

    addAtom({ scope, "PARAM", "", "", result1.second }); //Добавляет команду "PARAM" для передачи параметра в список команд

    auto result = ArgListList(scope); //Рекурсивно вызывает ArgListList для обработки других аргументов
    if (!result.first) return { false, "" }; //Если результат неудачный, возвращает ошибку
    backStateIt(); //удаляет узел из дерева


    return { true, to_string(stoi(result.second) + 1) }; //Возвращает успешный результат с количеством обработанных аргументов, увеличенным на 1
}

pair<bool, string> LL::ArgListList(const string& scope) {
    if (iter->first == "comma") { //Если текущая лексема — это запятая comma
        setLexem(); // берем следующую лексему
        if (iter->first != "num" and iter->first != "char" and iter->first != "id" and iter->first != "opinc" and iter->first != "lpar")
            return { false, "" }; //Если это не число, символ, идентификатор или скобка, возвращает ошибку
        //Добавляет узел "comma E" в дерево, указывая, что дальше следует выражение после запятой
        nextState(1); // добавляет текущий узел для дерева в вектор и говорит, что он не является правым
        addString("comma E"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов

        auto result1 = E(scope); //Вызывает функцию E для обработки выражения после запятой
        if (!result1.first) { return { false, "" }; } //Если неудача, возвращает ошибку

        //Добавляет узел "Arglist'" для оставшихся аргументов
        nextState(0); // добавляет текущий узел для дерева в вектор и говорит, что он является правым
        addString("Arglist'"); // дает название узлу, и рисует его на дереве, основываясь на векторе текущих узлов

        //Рекурсивно вызывает ArgListList для обработки следующих аргументов
        auto result = ArgListList(scope); // помещаем результат обхода дальше во временную переменную
        if (!result.first) return { false, "" }; // проверка, что верны данные дальше

        //Удаляет узел из дерева и добавляет команду "PARAM" для передачи текущего параметра в список команд
        backStateIt(); 
        addAtom({ scope, "PARAM", "", "", result1.second });

        //Возвращает успешный результат с количеством обработанных аргументов, увеличенным на 1
        return { true, to_string(stoi(result.second) + 1) };
    }
    backStateIt(); //удаляем уже обработанный узел из ветора текущих узлов
    return { true, "0" };
}